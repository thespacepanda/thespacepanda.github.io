{"version":3,"sources":["daiquiri/util.cljc"],"mappings":";AAIA,AAAA,AAAMA,AAAYC;AAAlB,AACE,AAAI,AAAAC,AAAUD,AACV,AAASA,AACT,AAAAE,AAASF;;AAEf,AAAA,AAAMG,AAAaH;AAAnB,AACE,AAAI,AAASA;AACXA;;AACA,AAAAI,AAA2B,AAAA,AAAQ,AAACQ,AAAKZ;AAAzCK,AAAA,AAAAC,AAAAF;AAAAG,AAAA,AAAAC,AAAAH;AAAAA,AAAA,AAAAI,AAAAJ;AAAAE,AAAOG;AAAPL,AAAoBM;AAApB,AACE,AAAI,AAAI,AAACE,AAAOF,AACR,AAAA,AAACG,AAASJ,AACV,AAAA,AAACI,AAASJ;AAChBV;;AACA,AAAA,AAAI,AAACe,AAAIC,AAAeL,AACpB,AAACM,AAAKP,AACNQ,AACAC;;;;AAEZ,AAAKC,AAAY,AAAA,AAACC;AAElB;;;;AAAA,AAAMC,AAGHtB;AAHH,AAIE,AAAI,AAACD,AAAWC;AACd,AAAAuB,AAAI,AAAA,AAAAC,AAACC,AAAKL,AAAYpB;AAAtB,AAAA,AAAAuB;AAAAA;;AACI,AAAMG,AAAG,AAACvB,AAAYH;AAAtB,AACE,AAAA,AAAA,AAAQoB,AAAAA,AAAYO,AAAM3B,AAAE0B;;AAC5BA;;;AACN1B;;;AAEJ;;;AAAA,AAAM4B,AAEHC;AAFH,AAGE,AAAI,AAACC,AAAKD;AACR,AAAMA,AAAE,AACK,AAAA,AAAAE,AAAAC,AAAAC,AAACC,AAEDG;AAFA,AAAY,AAAAN,AAAAE,AAACE,AAAU,AAAAH,AAACV;AADxBO,AAEW,AAAA,AAACO;AAFzB,AAIE,AAAAE,AAAQT;AAAR,AAAA,AACE,AAACC,AAAK,AAAA,AAAQD;AACd,AAAAS,AAAA,AAACC,AAAcX;;AAFjBU;;;AAGFT;;;AAEJ;;;;AAAA,AAAMW,AAGHC;AAHH,AAIE,AAAK,AAACC,AAAQD,AACT,AAAAxC,AAAU,AAAA,AAAA,AAAC0C,AAAIF;;AAEtB;;;AAAA,AAAMG,AAEHC;AAFH,AAGE,AAAA,AAAA,AAAA,AAAA,AAAA,AAACC,AAAY,AAAClB,AAAgBiB;;AAIhC;;;AAAA,AAAME,AAEHC;AAFH,AAIO,AAAA,AAACC,AAAQ,AAACC,AACA,AAACC,AAAO,AAAKV,AAEvB,AAAA,AAACvB;AAFiB,AAAQ,AAAI,AAASuB;AAAb,AAAiBA;;AAAG,AAACnC,AAAImC;;AAFnDO,AAGU,AAACI,AAAOC","names":["daiquiri.util/valid-key?","k","cljs.core/Keyword","cljs.core/Symbol","daiquiri.util/-camel-case","vec__25880","seq__25881","cljs.core/seq","first__25882","cljs.core/first","cljs.core/next","first-word","words","cljs.core/name","cljs.core/empty?","cljs.core._EQ_","cljs.core.map","clojure.string/capitalize","cljs.core.conj","clojure.string.join","cljs.core.keyword","daiquiri.util/attrs-cache","cljs.core/volatile!","daiquiri.util/camel-case","or__4126__auto__","cljs.core/deref","cljs.core.get","kk","cljs.core.assoc","daiquiri.util/camel-case-keys","m","cljs.core/map?","p1__25883#","p2__25884#","p3__25885#","cljs.core/reduce-kv","cljs.core.assoc_BANG_","cljs.core/transient","cljs.core/persistent!","G__25886","cljs.core.update","daiquiri.util/element?","x","cljs.core/vector?","cljs.core.nth","daiquiri.util/html-to-dom-attrs","attrs","clojure.set/rename-keys","daiquiri.util/join-classes","classes","cljs.core.into","cljs.core.comp","cljs.core.mapcat","cljs.core.remove","cljs.core/nil?"],"sourcesContent":["(ns daiquiri.util\n  (:require [clojure.set :refer [rename-keys]]\n            [clojure.string :as str]))\n\n(defn valid-key? [k]\n  (or (keyword? k)\n      (string? k)\n      (symbol? k)))\n\n(defn -camel-case [k]\n  (if (string? k)\n    k\n    (let [[first-word & words] (.split (name k) \"-\")]\n      (if (or (empty? words)\n              (= \"aria\" first-word)\n              (= \"data\" first-word))\n        k\n        (-> (map str/capitalize words)\n            (conj first-word)\n            str/join\n            keyword)))))\n\n(def attrs-cache (volatile! {}))\n\n(defn camel-case\n  \"Returns camel case version of the key, e.g. :http-equiv becomes :httpEquiv.\n  Does not convert string attributes.\"\n  [k]\n  (if (valid-key? k)\n    (or (get @attrs-cache k)\n        (let [kk (-camel-case k)]\n          (vswap! attrs-cache assoc k kk)\n          kk))\n    k))\n\n(defn camel-case-keys\n  \"Recursively transforms all map keys into camel case.\"\n  [m]\n  (if (map? m)\n    (let [m (->> m\n                 (reduce-kv #(assoc! %1 (camel-case %2) %3)\n                            (transient {}))\n                 persistent!)]\n      (cond-> m\n        (map? (:style m))\n        (update :style camel-case-keys)))\n    m))\n\n(defn element?\n  \"Return true if `x` is an HTML element. True when `x` is a vector\n  and the first element is a keyword, e.g. `[:div]` or `[:div [:span \\\"x\\\"]`.\"\n  [x]\n  (and (vector? x)\n       (keyword? (nth x 0 nil))))\n\n(defn html-to-dom-attrs\n  \"Converts all HTML attributes to their DOM equivalents.\"\n  [attrs]\n  (rename-keys (camel-case-keys attrs)\n               {:class :className\n                :for :htmlFor}))\n\n(defn join-classes\n  \"Join the `classes` with a whitespace.\"\n  [classes]\n  (->> classes\n       (into [] (comp\n                 (mapcat (fn [x] (if (string? x) [x] (seq x))))\n                 (remove nil?)))\n       (str/join \" \")))\n"]}